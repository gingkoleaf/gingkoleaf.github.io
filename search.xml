<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yum源优先级配置]]></title>
    <url>%2F2019%2F06%2F30%2Fcentos%2Fyum-priorities%2F</url>
    <content type="text"></content>
      <categories>
        <category>linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[epel配置与使用]]></title>
    <url>%2F2019%2F06%2F30%2Fcentos%2Fepel%2F</url>
    <content type="text"><![CDATA[为了保证稳定性，RHEL及其衍生版本Centos等的官方rpm repository中提供的软件版本都相对比较滞后。为了能使用相对较新的软件版本，可以使用EPEL扩展源。 EPEL(Extra Packages for Enterprise Linux)，是由Fedora社区维护的，为RHEL系列操作系统提供高质量软件包的项目。 yum命令安装1yum -y install epel-release rpm包安装根据系统CPU架构及操作系统版本，到 https://dl.fedoraproject.org/pub/epel/ 下载对应的rpm进行安装。 12wget wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -ivh epel-release-latest-7.noarch.rpm 或 1yum -y install http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 验证12345678910111213$ yum clean all; yum makecache$ yum repolistLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.tuna.tsinghua.edu.cn * extras: mirrors.aliyun.com * updates: mirrors.aliyun.comrepo id repo name statusbase/7/x86_64 CentOS-7 - Base - mirrors.aliyun.com 10,019epel/x86_64 Extra Packages for Enterprise Linux 7 - x86_64 13,242extras/7/x86_64 CentOS-7 - Extras - mirrors.aliyun.com 419updates/7/x86_64 CentOS-7 - Updates - mirrors.aliyun.com 2,137repolist: 25,817]]></content>
      <categories>
        <category>linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>epel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git内部原理]]></title>
    <url>%2F2019%2F06%2F30%2Fgit%2Fgit-internals%2F</url>
    <content type="text"><![CDATA[概述Git从根本上说是一个基于内容寻址(content-addressable)的文件系统，并在此之上提供一个VCS的用户界面。 最初git只是为VCS提供的一套工具集，而不是一个完成的VCS，所以git存在一系列命令能完成一些底层操作，这些命令被设计为能以Unix-style连接(chained)在一起，或者可以被脚本调用。这些命令被称为底层(plumbing)命令。相对应的那些更友好(user-friendly)的命令被称为高层(porcelain)命令。 通常情况下，不会在命令行中直接使用这些底层命令，它们更多被用于构建新的命令或用于自定义的脚本。 .git目录在执行完git init命令后，会生成一个.git目录。该目录里面包含了几乎所有的git存储和操作的对象。如果你想备份或克隆一个你的repo，只需要将copy该目录即可。 .git目录内容如下: 1234567891011$ ls -F1COMMIT_EDITMSGconfig # 包含所有特有(project-specific)的配置项description # 该文件仅用于GitWeb程序，无需关注HEAD # imp，hooks/ # 保存服务端和客户端的git钩子脚本index # imp,info/ # 该目录下的exclude文件用于保存不希望配置在.gitignore文件中的忽略模式logs/objects/ # imp, 存储所有的数据内容，包括所有文件的历史版本和commit信息refs/ # imp, 文件HEAD、index和目录objects、refs是git系统的核心组成部分。 参考资料 ProGit]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git diff命令详解]]></title>
    <url>%2F2019%2F06%2F29%2Fgit%2Fgit-cmd-diff%2F</url>
    <content type="text"><![CDATA[命令回显说明git diff命令的回显采用的时GNU diff命令合并格式的变体 linux下通过diff -u file_a file_b来显示diff的合并格式 内容增删12345678910111213141516171819202122232425262728293031&gt; git diff HEAD~1 HEADdiff --git a/README.md b/README.md # 表示显示内容为git格式的diffindex ae50fdb..54e2aab 100644 # ae50fab..54e2aab表示两个版本对象的哈希值 # 100644表示对象的模式(普通文件， 644权限)--- a/README.md # --- 表示变动前的版本+++ b/README.md # +++ 表示变动后的版本@@ -5,6 +5,7 @@ # 该行表示变动的位置，由两个@表示开头和结尾 # - 表示 文件a/README.md， + 表示文件b/README.md # 5,6 表示下方显示内容为a/README.md的第5行开始，连续6行 # 5,7 表示下方显示内容为b/README.md的第5行开始，连续7行 b c d+new line e f gdiff --git a/newfile b/newfileindex fd54aa0..2d3a259 100644--- a/newfile+++ b/newfile@@ -1,5 +1,7 @@ add new file 1-2-3++ds+honda+toyta 新增文件1234567891011diff --git a/newfile3 b/newfile3new file mode 100644index 0000000..d4afdcc--- /dev/null+++ b/newfile3@@ -0,0 +1,5 @@+add new file3++new file++new file end 删除文件12345678910111213diff --git a/newfile b/newfiledeleted file mode 100644index 2d3a259..0000000--- a/newfile+++ /dev/null@@ -1,7 +0,0 @@-add new file-1--ds-honda-toyta- 重命名文件12345678910111213141516diff --git a/deletefile b/newfile2similarity index 89%rename from deletefilerename to newfile2index 08cb754..389cecf 100644--- a/deletefile+++ b/newfile2@@ -1,8 +1,6 @@ file tobe rename 1 2-3-4 5 6 7]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用总结]]></title>
    <url>%2F2019%2F06%2F29%2Fgit%2Fgit-usage%2F</url>
    <content type="text"><![CDATA[常用术语 VCS: Version Control System 版本控制系统 DVCS: Distributed Version Control System 分布式版本控制系统 CVCS: Centralized Version Control System 中心式版本控制系统 Git内部原理Git命令git diff]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[groovy闭包]]></title>
    <url>%2F2019%2F06%2F13%2Fgroovy%2Fgroovy-closure%2F</url>
    <content type="text"><![CDATA[闭包定义在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 彼得·兰丁在1964年将术语“闭包”定义为一种包含环境成分和控制成分的实体。用来指代某些其开放绑定（自由变量）已经由其语法环境完成闭合（或者绑定）的lambda表达式，从而形成了闭合的表达式，或称闭包。 闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。 在函数定义时捕获当时的引用环境，并与函数代码组合成一个整体。当把这个整体当作函数调用时，先把其中的引用环境覆盖到当前的引用环境上，然后执行具体代码，并在调用结束后恢复原来的引用环境。这样就保证了函数定义和执行时的引用环境是相同的。这种由引用环境与函数代码组成的实体就是闭包。 自由变量是指除局部变量以外的变量。 Groovy闭包定义Groovy中的闭包是一个开放的、匿名代码块，它可以接收参数，定义返回值，也可以将闭包复制给变量，闭包还可以引用定义在其周围范围(in its surrounding scope)中的变量。与闭包的正式定义相反，Groovy语言中的闭包还可以包含定义在其周围范围之外(outside of its surrounding scope)的自由变量。 Groovy闭包语法1234567891011121314151617181920212223242526272829303132333435363738&#123; [closureParameters -&gt;] statements&#125;// examples&#123; item++ &#125; // 引用变量item// 默认参数it// 如果闭包执行时未指定参数，则it为null，类型class org.codehaus.groovy.runtime.NullObject&#123; println it&#125;//显示指定参数&#123;name -&gt; println name&#125;//指定多个具有类型的参数def body = &#123;String name, int age -&gt; println "name: $&#123;name&#125;, age:$&#123;age&#125;"&#125;//闭包是groovy.lang.Closure类型的实例assert body instanceof Closure//参数可以指定默认值def sum = &#123; int a, int b=2 -&gt; a+b &#125;//可以指定闭包的返回值类型Closure&lt;Boolean&gt; isTextFile = &#123; File it -&gt; it.name.endsWith('.txt')&#125;//如果要明确指定闭包不包含参数，需要显示的指定空参数列表def magicNumber = &#123; -&gt; 42 &#125;// this call will fail because the closure doesn't accept any argumentmagicNumber(11)//闭包的可以指定最后一个参数的长度是可变的或定义为数组def concat1 = &#123;String... args -&gt; args.join('')&#125;assert concat1('abc', 'def') == 'abcdef'def concat2 = &#123;String[] args -&gt; args.join('')&#125;assert concat2('aaa', 'bbb') == 'aaabbb'//闭包的执行也可以使用call()def multiConcat = &#123;int n, String... args -&gt; args.join('')*n&#125;assert multiConcat.call(3, 'ab', 'cd') == 'abcdabcdabcd' closureParameters是可选的逗号分隔的参数列表，参数可以指定类型(typed)也可不指定类型(untyped)。如果指定了参数，参数后面必须有 -&gt;，用于分割参数和闭包内语句。 闭包执行时，总是会有返回值。 Groovy闭包委托策略(Delegation strategy)委托(Delegation)是Groovy闭包中的一个关键特性(key concept)，闭包委托策略的可修改使得在Groovy中设计漂亮的领域特定语言(dsl, domain specific language)成为可能。 this、owner、delegate闭包内有三个内置对象: this 对应于定义闭包的封闭类(the enclosing class where the closure is defined),可以在闭包内通过getThisObject()获取 owner 对应于定义闭包的封闭对象(the enclosing object where the closure is defined)，可以是类也可以是闭包，可以在闭包内通过getOwner()获取 delegate 对应于一个第三方对象(where methods calls or properties are resolved whenever the receiver of the message is not defined)，可以在闭包内通过(getDelegate())获取 通过这三个内置对象，闭包可以调用对应对象的属性和方法。 this对应于定义闭包的封闭类12345678910111213141516171819202122// 在TestThis类中定义闭包body，并返回闭包的this对象class TestThis&#123; void run() &#123; def body = &#123;getThisObject()&#125; // 调用闭包会返回TestThis类的实例 assert body() == this // 在闭包中直接使用this对象与调用getThisObject等价 def body2 = &#123; this &#125; assert body2 == this &#125;&#125;class ClosureTest &#123; static void main(String... args) &#123; def body = &#123; this &#125; println body() == this // true println this // class ClosureTest println(this.getClass().toString()) // class java.lang.Class println(body.getClass().toString()) // class ClosureTest$_main_closure1 println body instanceof Closure // true &#125;&#125; 如果闭包在内部类中定义，那么闭包中的 this 对象返回的是内部类的实例对象1234567891011121314151617class ClosureTest &#123; class InnerClass &#123; def body = &#123; this &#125; &#125; void run()&#123; InnerClass inner = new InnerClass() println inner == inner.body() // true println this == inner.body() // false println this.getClass().toString() // class ClosureTest println inner.getClass().toString() // class ClosureTest$InnerClass println inner.body.getClass().toString() // class ClosureTest$InnerClass$_closure1 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 如果闭包A嵌入在类的某个闭包B中时，闭包A中的 this 表示的仍然是类的实例对象12345678910111213141516class ClosureTest &#123; void run()&#123; def body_b = &#123; def body_a = &#123; this &#125; body_a() &#125; println body_b() // ClosureTest@25748410 println this // ClosureTest@25748410 println body_b() == this // true println this.getClass().toString() // class ClosureTest &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; owner返回闭包定义所在的封闭对象，可以是类也可以是闭包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 普通类class ClosureTest &#123; void run()&#123; def body_b = &#123; owner &#125; println body_b() // ClosureTest@55b5f5d2 println body_b // ClosureTest$_run_closure1@5bfa8cc5 println this // ClosureTest@55b5f5d2 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125;// 内部类class ClosureTest &#123; class InnerClass &#123; def body = &#123; owner &#125; &#125; void run() &#123; def inner = new InnerClass() println inner // ClosureTest$InnerClass@553f1d75 println inner.body() // ClosureTest$InnerClass@553f1d75 println this // ClosureTest@47404bea &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125;// 嵌套闭包class ClosureTest &#123; void run()&#123; def body_b = &#123; def body_a = &#123; owner &#125; println body_a // ClosureTest$_run_closure1$_closure2@5bfa8cc5 println body_a() // ClosureTest$_run_closure1@16ecee1 body_a() &#125; println body_b() // ClosureTest$_run_closure1@16ecee1 println body_b // ClosureTest$_run_closure1@16ecee1 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; delegate委托是Groovy语言能够构建DSL的关键特性(It is a powerful concept for building domain specific languages in groovy)。delegate是一个用户自定义的对象。 默认情况下， delegate 等同于 owner123456789101112131415161718192021222324252627class ClosureTest &#123; class InnerClass &#123; def body = &#123; delegate &#125; &#125; void run() &#123; def inner = new InnerClass() println inner // ClosureTest$InnerClass@4f071df8 println inner.body() // ClosureTest$InnerClass@4f071df8 println this // ClosureTest@29e6eb25 def body_b = &#123; def body_a = &#123; delegate &#125; body_a() &#125; println body_b() // ClosureTest$_run$_closure1@38be305c println body_b // ClosureTest$_run$_closure1@38be305c def body_c = &#123; delegate &#125; println body_c() // ClosureTest@29e6eb25 println body_c // ClosureTest$_run$_closure2@5ed731d0 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 闭包中的delegate属性可以被修改为任何对象123456789101112131415161718192021222324252627282930class ClosureTest &#123; class Person &#123; String name &#125; class Animal &#123; String name &#125; void run() &#123; def p = new Person(name: 'john') def a = new Animal(name: 'panda') def nameToUpper = &#123; delegate.name.toUpperCase() &#125; nameToUpper.delegate = p println nameToUpper() // JOHN nameToUpper.delegate = a println nameToUpper() // PANDA println p.name // john println a.name // panda // nameToUpper_use_var引用外部的局部变量p，能够达成和前面使用delegate一样的效果 // 但是委托可以透明的使用，即在闭包中不再显式的采用 delegate. 前缀引用属性或方法，详情见下节委托策略 def nameToUpper_use_var = &#123; p.name.toUpperCase() &#125; println nameToUpper_use_var() // JOHN &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 闭包委托策略在闭包中，如果访问闭包内部未定义的属性或方法时，会涉及到委托策略，委托策略分为下面几种: Closure.OWNER_FIRST: 默认策略。优先在owner中查找，如果没有找到则在delegate中查找 Closure.DELEGATE_FIRST: 优先在delegate中查找, 如果没有找到则在owner中查找 Closure.OWNER_ONLY: 忽略delegate，只在owner中查找 Closure.DELEGATE_ONLY: 忽略owner, 只在delegate中查找 Closure.TO_SELF: 只有在实现自己的闭包子类时才有意义。在需要高级元编程(meta-programming)技术，希望实现自定义的解析策略: 属性或方法的解析既不使用owner也不使用delegate，only on the closure class itself. DELEGATE_FIRST 与 OWNER_FIRST1234567891011121314151617181920212223242526272829303132333435class ClosureTest &#123; class Person &#123; String name def output = &#123; "My name is $&#123;name&#125;" &#125; String outputstring() &#123; output() &#125; &#125; class Animal &#123; String name &#125; void run() &#123; def p = new Person(name: 'john') def a = new Animal(name: 'panda') println p.output.owner // ClosureTest$Person@3234f74a println p.output.delegate // ClosureTest$Person@3234f74a // 默认委托策略为owner_first所以从p中查找name属性 println p.outputstring() // My name is john p.output.delegate = a println p.output.owner // ClosureTest$Person@3234f74a println p.output.delegate // ClosureTest$Animal@65aa6596 // 只修改了delegate属性，但策略没变，仍然从p中查找name属性 println p.outputstring() // My name is john // 修改委托策略为delegate_first p.output.resolveStrategy = Closure.DELEGATE_FIRST // 从a中查找name属性 println p.outputstring() // My name is panda &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; DELEGATE_FIRST 与 DELEGATE_OWNER123456789101112131415161718192021222324252627282930313233class ClosureTest &#123; class Person &#123; String name int age def output = &#123; "$&#123;name&#125; age is $&#123;age&#125;" &#125; String outputstring() &#123; output() &#125; &#125; class Animal &#123; String name &#125; void run() &#123; def p = new Person(name: 'john', age: 18) def a = new Animal(name: 'panda') println p.outputstring() // john age is 18 p.output.delegate = a println p.outputstring() // john age is 18 p.output.resolveStrategy = Closure.DELEGATE_ONLY p.output.delegate = p println p.outputstring() // john age is 18 p.output.delegate = a // exception: // groovy.lang.MissingPropertyException: No such property: age for class: ClosureTest println p.outputstring() &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 闭包委托策略具有传递性闭包A内嵌与闭包B时，如果闭包A中的某个属性在闭包B中没有解析到会继续向闭包B的owner或delegate中查找。具体是向闭包的B的owner还是delegate中查找，由闭包B的委托策略决定 12345678910111213141516171819202122232425262728293031323334class ClosureTest &#123; class Person &#123; String name int age def outerClosure = &#123; // outerClosure为innerClosure的owner def name = "outer_$&#123;name&#125;" def innerClosure = &#123; // innerClosure闭包中的name和age属性都不在闭包内定义 // 默认从innerClosure.owner中查找 // outerClousre.name // p.age "$&#123;name&#125;'s age is $&#123;age&#125;" &#125; println innerClosure.owner // ClosureTest$Person$_closure1@26a4842b println innerClosure.delegate == innerClosure.owner // ture innerClosure() &#125; &#125; void run() &#123; def p = new Person(name: 'john', age: 18) println p // ClosureTest$Person@5ed731d0 // p.outerClosure的owner为 p println p.outerClosure // ClosureTest$Person$_closure1@26a4842b println p.outerClosure.delegate == p // true println p.outerClosure.owner == p // true println p.outerClosure() // outer_john's age is 18 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 1234567891011121314151617181920212223242526class ClosureTest &#123; class Person &#123; String name int age def outerClosure = &#123; def name = "outer_$&#123;name&#125;" def innerClosure = &#123; "$&#123;name&#125;'s age is $&#123;age&#125;" &#125; innerClosure() &#125; &#125; void run() &#123; def p = new Person(name: 'john', age: 18) def p2 = new Person(name: 'jessica', age: 3) println p.outerClosure() // outer_john's age is 18 p.outerClosure.resolveStrategy = Closure.DELEGATE_FIRST p.outerClosure.delegate = p2 println p.outerClosure() // outer_jessica's age is 3 &#125; static void main(String... args) &#123; new ClosureTest().run() &#125;&#125; 闭包策略在Jenkins pipeline中的典型应用12345678910111213141516171819// vars/abc.groovydef call(body) &#123; def config = [:] // 修改body闭包的委托策略和delegate属性 body.resolveStrategy = Closure.DELEGATE_FIRST body.delegate = config // 闭包执行时，闭包中读取未定义的属性时都会从config中获取 // 闭包中设置未定义的属性时都也会设置到config中 body() // 后续就可以通过config.branch访问Jenkinsfile中定义并传给abc.groovy的值 println config // [branch: 'master']&#125;// Jenkinsfileabc &#123; // 通常设置某些属性值，可以实现传参效果 branch = 'master'&#125; 参考资料维基百科-闭包 闭包的概念、形式与应用 (IBM DeveloperWorks) Groovy-Closure]]></content>
      <categories>
        <category>language</category>
        <category>groovy</category>
      </categories>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[groovy使用总结]]></title>
    <url>%2F2019%2F06%2F13%2Fgroovy%2Fgroovy-usage%2F</url>
    <content type="text"><![CDATA[Apache Groovy基于Java平台的一种功能强大、可选类型的动态语言。它的目的在于通过简洁、熟悉和易于学习的语法来提升开发人员的效率。Groovy代码动态地编译成运行于Java虚拟机（JVM）上的Java字节码，并可以与其他Java代码和库进行互操作。由于其运行在JVM上的特性，Groovy可以使用其他Java语言编写的库。 官网文档 闭包]]></content>
      <categories>
        <category>language</category>
        <category>groovy</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[etcd_introduce]]></title>
    <url>%2F2019%2F06%2F02%2Fetcd%2Fetcd-introduce%2F</url>
    <content type="text"><![CDATA[官网github 简介etcd官方定义为一个分布式的可信的键值存储服务，用于存储分布式系统中的一些关键数据。其主要特性包括: Simple 简单: 包含一套定义良好、面向用户的API(gRpc) Secure 安全: 支持可选择客户端证书认证的TLS Fast 快速: 基准测试可达10,000写每秒 Reliable 可靠: properly distributed using Raft etcd是使用Go语言编写，采用Raft共识算法管理高可用的replicated log。 安装 最简单的方式是在github的release中下载预编译(pre-built)好的二进制 源码安装a) etcd源码安装时对go版本通常都有要求，请参照github中说明b) 为了确保etcd编译正确，etcd提供了官方release版本的依赖。当然是否使用官方提供的依赖是可选的。 部署预置条件]]></content>
      <categories>
        <category>DB</category>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVEN POM]]></title>
    <url>%2F2019%2F06%2F01%2Fmaven%2Fmaven-pom%2F</url>
    <content type="text"><![CDATA[Maven的超级POM(Project Object Model)位于${M2_HOME}/lib/maven-model-builder-xxx.jar构件中org.apache.maven.model.pom-4.0.0.xml其中包含了Maven用于构建项目有关的项目信息以及配置细节，它包含了大多数项目的默认值。超级POM是Maven的默认POM，除非显式设置(POM中的&lt;parent>配置)，否则所有的POM都会扩展超级POM，也就是说项目POM默认都会继承超级POM中的配置。 POM最小内容123456&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; modelVersion内容要设置为4.0.0。groupId、artifactId和version三个元素定义了项目的坐标。 ### Super POM(3.6.1)内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- START SNIPPET: superpom --&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Plugin Repository&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;build&gt; &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt; &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt; &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;reporting&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt; &lt;/reporting&gt; &lt;profiles&gt; &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt; &lt;profile&gt; &lt;id&gt;release-profile&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt;&lt;!-- END SNIPPET: superpom --&gt;]]></content>
      <categories>
        <category>tool</category>
        <category>构建工具</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pipeline并行任务配置]]></title>
    <url>%2F2019%2F05%2F30%2Fjenkins%2Fjenkins-pipeline-parallel%2F</url>
    <content type="text"><![CDATA[静态并行任务配置声明式 在stage中可以通过parallel块来嵌套多个stage实现并行运行 parallel块中的stage除了不能再次嵌套parallel外和普通stage一样，也可以通过stages包含一些列顺序执行的stage 每个stage中有且只能有一个steps、stages或者parallel 所有包含parallel的stage都不能包含agent和tools EXAMPLE-1 stage级别并行123456789101112131415161718192021222324252627282930313233pipeline &#123; agent any options &#123; timestamps() &#125; stages &#123; stage(&apos;init&apos;) &#123; steps &#123; echo &quot;init start&quot; sleep 5 echo &apos;init end&apos; &#125; &#125; stage(&apos;build&apos;) &#123; parallel &#123; stage(&apos;x86 build&apos;) &#123; steps &#123; echo &apos;x86 build start&apos; sleep 5 echo &apos;x86 build end&apos; &#125; &#125; stage(&apos;arm build&apos;) &#123; steps &#123; echo &apos;arm build start&apos; sleep 3 echo &apos;arm build end&apos; &#125; &#125; &#125; &#125; &#125;&#125; blueOcean如下图所示 EXAMPLE-2 并行stage中多个stage串行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pipeline &#123; agent any options &#123; timestamps() &#125; stages &#123; stage(&apos;init&apos;) &#123; steps &#123; echo &quot;init start&quot; sleep 5 echo &apos;init end&apos; &#125; &#125; stage(&apos;build&apos;) &#123; parallel &#123; stage(&apos;x86 build&apos;) &#123; agent &#123; label &apos;master&apos; &#125; steps &#123; echo &apos;x86 build start&apos; sleep 5 echo &apos;x86 build end&apos; &#125; &#125; stage(&apos;arm build&apos;) &#123; stages &#123; stage(&apos;arm-master build&apos;) &#123; steps &#123; echo &apos;arm master build start&apos; sleep 3 echo &apos;arm master build end&apos; &#125; &#125; stage(&apos;arm develop build&apos;) &#123; steps &#123; echo &apos;arm develop build start&apos; sleep 3 echo &apos;arm develop build end&apos; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; blueOcean如下图所示 EXAMPLE-4 step级别并行12345678910111213141516171819202122232425262728pipeline &#123; agent any options &#123; timestamps() &#125; stages &#123; stage(&apos;init&apos;) &#123; steps &#123; echo &quot;init start&quot; sleep 5 echo &apos;init end&apos; &#125; &#125; stage(&apos;build&apos;) &#123; steps &#123; parallel &apos;x86 build&apos;: &#123; echo &apos;x86 build start&apos; sleep 3 echo &apos;x86 build end&apos; &#125;, &apos;arm build&apos;: &#123; echo &apos;arm build start&apos; sleep 3 echo &apos;arm build end&apos; &#125; &#125; &#125; &#125;&#125; blueOcean如下图所示 脚本式EXAMPLE-312345678910111213141516171819202122232425script &#123; node(&apos;master&apos;) &#123; stage(&apos;init&apos;) &#123; echo &apos;init&apos; &#125; stage(&apos;build&apos;) &#123; parallel &apos;build x86&apos;: &#123; stage(&apos;build x86 step1&apos;) &#123; echo &apos;build x86 step1 start&apos; sleep 5 echo &apos;build x86 step1 end&apos; &#125; stage(&apos;build x86 step2&apos;) &#123; echo &apos;build x86 step 2 start&apos; sleep 5 echo &apos;build x86 step 2 end&apos; &#125; &#125;, &apos;build arm&apos;: &#123; echo &apos;build arm start&apos; sleep 6 echo &apos;build arm end&apos; &#125; &#125; &#125;&#125; blueOcean如下图所示 动态创建并行任务EXAMPLE-51234567891011121314151617181920212223242526272829303132333435363738def jobs = [&apos;jobA&apos;, &apos;jobB&apos;, &apos;jobC&apos;]def parallelStagesMap = jobs.collectEntries &#123; def jobName -&gt; [&quot;$&#123;jobName&#125;&quot;, generateJobStage(jobName)]&#125;def generateJobStage(String jobName) &#123; return &#123; node(&apos;master&apos;) &#123; stage(&quot;stage: $&#123;jobName&#125;&quot;) &#123; echo &quot;$&#123;jobName&#125; start&quot; sleep 5 echo &quot;job end&quot; &#125; &#125; &#125;&#125;pipeline &#123; agent any options &#123; timestamps() &#125; stages &#123; stage(&apos;non-parallel stage&apos;) &#123; steps &#123; echo &apos;this is non-parallel stage&apos; &#125; &#125; stage(&apos;parallel stage&apos;) &#123; steps &#123; script &#123; parallel parallelStagesMap &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>tool</category>
        <category>持续集成</category>
        <category>jenkins</category>
        <category>pipeline</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven 使用总结]]></title>
    <url>%2F2019%2F05%2F23%2Fmaven%2Fmaven-usage%2F</url>
    <content type="text"><![CDATA[maven官方文档易百教程maven库查询 安装下载二进制包后解压即可，然后配置环境变量 12echo 'export M2_HOME=/usr/local/apache_maven_xxx' &gt;&gt; /etc/profileecho 'export PATH=$M2_HOME/bin:$PATH' &gt;&gt; /etc/profile 执行mvn -v查看版本，同时确认是否安装配置OK 配置超级POM配置文件maven的配置文件有三个级别 项目级，位于项目workspace目录下的pom.xml 用户级，位于~/.m2/settings.xml，通过mvn -s /path/to/settings.xml可以覆盖用户级配置文件 全局级，位于${M2_HOME}/conf/settings.xml，通过mvn -gs /path/to/settings.xml可以覆盖全局配置文件 配置项目 标签 类型 说明 localRepository String 本地仓库路径，默认位于~/.m2/repository mirrors List&lt;mirror> 配置仓库的下载镜像 mirrorOf配置 * = everything external:* = everything not on the localhost and not file based. repo,repo1 = repo or repo1 *,!repo1 = everything except repo1 镜像设置阿里镜像公共代理库使用文档 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimavenpublic&lt;/id&gt; &lt;name&gt;aliyun maven public&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/repository/public&lt;/url&gt; &lt;mirrorOf&gt;central,jcenter&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 华为镜像12345&lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt;&lt;/mirror&gt; Maven仓库对于Maven来说，仓库只有两类: 本地仓库和远程仓库。当Maven根据坐标寻找构件时，首先查找本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库没有此构件，或需要查看构件是否有更新，Maven会去远程仓库查找，找到后下载到本地仓库再使用，如果没有找到则报错。 对于远程仓库，根据仓库的提供者又可以分为: 中央仓库、其他公开库和私服中央仓库是Maven自带的远程仓库，它包含了绝大部分开源的构件。默认情况下，当本地仓库没有找到需要的构件时，Maven会尝试从中央仓库下载。 Maven常用命令Help命令查看某个插件的详情1mvn help:describe -Dplugin=xxx -Ddetail plugin可以使用下面三种方式指定: 插件前缀, 如 ‘help’ groupId:artifactId, 如 ‘org.apache.maven.plugins:maven-help-plugin’ groupId:artifactId:version, 如 ‘org.apache.maven.plugins:maven-help-plugin:2.0’ 查看某个插件的指定命令的帮助1mvn archetype:help -Ddetail -Dgoal=generate 使用archetype创建Maven项目12mvn archetype:generatemvn -U archetype:generate -Dfilter=io.jenkins.archetypes:]]></content>
      <categories>
        <category>tool</category>
        <category>构建工具</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vm_network]]></title>
    <url>%2F2019%2F05%2F16%2Fvm-network%2F</url>
    <content type="text"><![CDATA[TODO1TODO2]]></content>
  </entry>
  <entry>
    <title><![CDATA[centos使用总结]]></title>
    <url>%2F2019%2F05%2F15%2Fcentos%2Fcentos-usage%2F</url>
    <content type="text"><![CDATA[最小化安装IP配置修改 /etc/sysconfig/network-scripts/ifcfg-xxx 文件 123456789TYPE=EthernetBOOTPROTO=static #网卡引导方式 static/DHCPONBOOT=yes #网卡开机启动IPADDR=192.168.0.150NETMASK=255.255.255.0GATEWAY=192.168.0.1HWADDR=xx:xx:xx:xx:xx:xxDNS1=x.x.x.xDNS2=x.x.x.x 然后重启网络服务 systemctl restart network 配置国内镜像源12345cat /etc/centos-releasemv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bakwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache epel扩展源yum源优先级yum命令搜索命令属于哪些包 yum search xxx yum provides xxx yum list 命令 描述 yum list [all] 所有已安装和可以安装的包 yum list available 所有可以安装的包 yum list installed 所有已经安装的包 yum list updates 所有可以升级的包 yum list extra 所有已经安装但不在repository的包 查看软件包详情 yum info wget 查看软件包依赖 yum deplist wget 工具安装与配置openjdk安装通过yum工具安装的位置为 /usr/lib/jvm/java-xxx 123yum install java-11-openjdk-devel.x86_64echo "export JAVA_HOME=/usr/lib/jvm/java-11-openjdk" &gt;&gt; /etc/profileecho 'export PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profile]]></content>
      <categories>
        <category>linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile使用总结]]></title>
    <url>%2F2019%2F05%2F14%2Fmakefile-usage%2F</url>
    <content type="text"><![CDATA[常用链接跟我一起写Makefile重制版GUN Make手册 makefile中添加打印信息1234warn_msg="warning..."$(info "infomation output")$(warning "warn: $(warn_msg)")$(error "error message") 常用参数 -n, --just-print 打印make过程中执行的所有命令但是并不会真正执行 --print-data-base make过程中会显示GNU信息、执行的命令以及make的内部数据库。数据库里面的数据分为以下几类1) variables 会列出每个变量及描述性注释2) directories 列出了将会被make检查的目录3) implicit rules 包含了所有内置和用户自定义的模式规则4) pattern-specific variables 定义在makefile中的模式专属变量5) files(explicit rules) 与特定文件有关的自定义和后缀规则6) vpath search paths]]></content>
      <categories>
        <category>tool</category>
        <category>构建工具</category>
        <category>makefile</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lvm使用]]></title>
    <url>%2F2019%2F05%2F13%2Flvm%2F</url>
    <content type="text"><![CDATA[LVM(Logic Volume Manager)逻辑卷管理，它是linux环境下对磁盘分区进行管理的一种机制。 TODO 基本术语 PV: Physical Volume 物理卷 VG: Volume Group 卷组，由一个或多个PV组成。可以在其上创建一个或多个LV LV: Logical Volume 逻辑卷，在其上可以创建文件系统 PE: Physical Extent 物理扩展盘区，每个PV都会被划分成PE，它是可以被LVM寻址的最小单元 LE: Logical Extent 逻辑扩展盘区， 基本原理1) 物理磁盘被格式化为PV，空间被划分为一个个PE2) 不同的PV加入到同一个VG中，其对应的所有PE都进入VG的PE池中3) LVM从PE池中选择PE创建LV，不同物理盘中的PE可能会划分到同一个LV中4) 在LV上创建文件系统后就可以挂载使用了5) 对LV的扩容和缩减其实就是相应的增加或减少PE数量 创建逻辑卷时，定义了逻辑扩展盘区与物理扩展盘区的映射关系。 创建流程创建分区12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): pPartition number (1-4, default 1): First sector (2048-2097151, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +300MPartition 1 of type Linux and of size 300 MiB is setCommand (m for help): pDisk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x233e2ebd Device Boot Start End Blocks Id System/dev/sdb1 2048 616447 307200 83 LinuxCommand (m for help): tSelected partition 1Hex code (type L to list all codes): 8eChanged type of partition 'Linux' to 'Linux LVM'Command (m for help): pDisk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x233e2ebd Device Boot Start End Blocks Id System/dev/sdb1 2048 616447 307200 8e Linux LVMCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks. 创建pv12345678910111213141516[root@localhost ~]# pvcreate /dev/sdb1 Physical volume "/dev/sdb1" successfully created.[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sdb1 lvm2 --- 300.00m 300.00m[root@localhost ~]# pvdisplay /dev/sdb1 --- Physical volume --- PV Name /dev/sdb1 VG Name vg0 PV Size 300.00 MiB / not usable 4.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 74 Free PE 74 Allocated PE 0 PV UUID 8dqEi7-haMt-ciIM-ib2e-AUxp-f7ym-bCvlfw 创建vg1234567891011121314151617181920212223242526[root@localhost ~]# vgcreate vg0 /dev/sdb1 Volume group "vg0" successfully created[root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree vg0 1 0 0 wz--n- 296.00m 296.00m[root@localhost ~]# vgdisplay vg0 --- Volume group --- VG Name vg0 System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 1 VG Access read/write VG Status resizable MAX LV 0 Cur LV 0 Open LV 0 Max PV 0 Cur PV 1 Act PV 1 VG Size 296.00 MiB PE Size 4.00 MiB Total PE 74 Alloc PE / Size 0 / 0 #已分配的PE数量 Free PE / Size 74 / 296.00 MiB #剩余的PE数量 VG UUID 3FH6og-yXLt-NaL3-uehk-9lrJ-c4TD-r0z6Sa 创建lv12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[root@localhost ~]# lvcreate -L 100m -n lv0 vg0 Logical volume "lv0" created.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv0 vg0 -wi-a----- 100.00m [root@localhost ~]# lvdisplay /dev/vg0/lv0 --- Logical volume --- LV Path /dev/vg0/lv0 LV Name lv0 VG Name vg0 LV UUID Plb1kl-JGcg-0UfR-W3Ue-tDBc-D5Tc-tj6X0n LV Write Access read/write LV Creation host, time localhost.localdomain, 2019-05-16 02:02:27 +0800 LV Status available # open 0 LV Size 100.00 MiB Current LE 25 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2[root@localhost ~]# pvdisplay /dev/sdb1 --- Physical volume --- PV Name /dev/sdb1 VG Name vg0 PV Size 300.00 MiB / not usable 4.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 74 Free PE 49 Allocated PE 25 # 可以看到已经有PE被分配出去了 PV UUID 8dqEi7-haMt-ciIM-ib2e-AUxp-f7ym-bCvlfw[root@localhost ~]# vgdisplay vg0 --- Volume group --- VG Name vg0 System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 2 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 0 Max PV 0 Cur PV 1 Act PV 1 VG Size 296.00 MiB PE Size 4.00 MiB Total PE 74 Alloc PE / Size 25 / 100.00 MiB # 可以看到已经有PE被分配出去了 Free PE / Size 49 / 196.00 MiB VG UUID 3FH6og-yXLt-NaL3-uehk-9lrJ-c4TD-r0z6Sa 创建LV时LV的大小有以下两种方式指定 通过-L参数，表示物理大小 通过-l参数，使用相关VG/LV或PV大小的百分比来指定 10%VG, 表示10%的VG总大小 20%FREE, 表示VG中剩余空间的20% 30%PVS, 表示PV集合中剩余空间的30% 该参数后面跟数值(非百分比)时，表示包含多少个PE大小。 12345678910111213[root@localhost ~]# lvremove /dev/vg0/lv0Do you really want to remove active logical volume vg0/lv0? [y/n]: y Logical volume "lv0" successfully removed[root@localhost ~]# lvcreate -l 30%VG -n lv1 vg0 Logical volume "lv1" created.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-a----- 88.00m [root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree centos 1 2 0 wz--n- &lt;9.00g 0 vg0 1 1 0 wz--n- 296.00m 208.00m[root@localhost ~]# 格式化文件系统1234567891011121314151617181920212223242526272829303132333435[root@localhost ~]# mkfs.ext3 /dev/vg0/lv1mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=1024 (log=0)Fragment size=1024 (log=0)Stride=0 blocks, Stripe width=0 blocks22528 inodes, 90112 blocks4505 blocks (5.00%) reserved for the super userFirst data block=1Maximum filesystem blocks=6737100811 block groups8192 blocks per group, 8192 fragments per group2048 inodes per groupSuperblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729Allocating group tables: done Writing inode tables: done Creating journal (4096 blocks): doneWriting superblocks and filesystem accounting information: done [root@localhost ~]# fdisk -l /dev/vg0/lv1 Disk /dev/vg0/lv1: 92 MB, 92274688 bytes, 180224 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes[root@localhost ~]# mkdir /usr1[root@localhost ~]# mount /dev/vg0/lv1 /usr1[root@localhost ~]# df -haFilesystem Size Used Avail Use% Mounted on/dev/mapper/vg0-lv1 82M 1.6M 76M 2% /usr1[root@localhost ~]# 扩容扩容LV1234567891011121314151617181920[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-ao---- 88.00m [root@localhost ~]# lvextend -L +100m /dev/vg0/lv1 Size of logical volume vg0/lv1 changed from 88.00 MiB (22 extents) to 188.00 MiB (47 extents). Logical volume vg0/lv1 successfully resized.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-ao---- 188.00m [root@localhost ~]# df -haFilesystem Size Used Avail Use% Mounted on/dev/mapper/vg0-lv1 82M 1.6M 76M 2% /usr1 # LV已经扩容但是文件系统大小还时原来大小[root@localhost ~]# resize2fs /dev/vg0/lv1 resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vg0/lv1 is mounted on /usr1; on-line resizing requiredold_desc_blocks = 1, new_desc_blocks = 1The filesystem on /dev/vg0/lv1 is now 192512 blocks long.[root@localhost ~]# df -haFilesystem Size Used Avail Use% Mounted on/dev/mapper/vg0-lv1 178M 1.6M 169M 1% /usr1 # 已经扩容 12345678910111213141516[root@localhost ~]# lvs |grep lv1 lv1 vg0 -wi-ao---- 188.00m [root@localhost ~]# lvextend -l +50%FREE /dev/vg0/lv1 Size of logical volume vg0/lv1 changed from 188.00 MiB (47 extents) to 244.00 MiB (61 extents). Logical volume vg0/lv1 successfully resized.[root@localhost ~]# lvs |grep lv1 lv1 vg0 -wi-ao---- 244.00m [root@localhost ~]# df -ha |grep lv1/dev/mapper/vg0-lv1 178M 1.6M 169M 1% /usr1[root@localhost ~]# resize2fs /dev/mapper/vg0-lv1 resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/mapper/vg0-lv1 is mounted on /usr1; on-line resizing requiredold_desc_blocks = 1, new_desc_blocks = 1The filesystem on /dev/mapper/vg0-lv1 is now 249856 blocks long.[root@localhost ~]# df -ha |grep lv1/dev/mapper/vg0-lv1 233M 2.1M 220M 1% /usr1 lvextend 中 -L 和 -l 参数中如果没有使用 + 号，则表示扩容到指定大小 扩容VG当VG中没有空闲资源时需要先扩容VG才能扩容LV 123456789101112131415161718192021222324252627[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sdb1 vg0 lvm2 a-- 296.00m 52.00m[root@localhost ~]# pvcreate /dev/sdc1 Physical volume "/dev/sdc1" successfully created.[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sdb1 vg0 lvm2 a-- 296.00m 52.00m /dev/sdc1 lvm2 --- 511.00m 511.00m[root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree vg0 1 1 0 wz--n- 296.00m 52.00m[root@localhost ~]# vgextend vg0 /dev/sdc1 Volume group "vg0" successfully extended[root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree vg0 2 1 0 wz--n- 804.00m 560.00m[root@localhost ~]# [root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-a----- 244.00m[root@localhost ~]# lvextend -l +100%FREE /dev/vg0/lv1 Size of logical volume vg0/lv1 changed from 244.00 MiB (61 extents) to 804.00 MiB (201 extents). Logical volume vg0/lv1 successfully resized.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-a----- 804.00m 缩减容量 先umount设备 缩减文件系统大小 缩减LV大小 123456789101112131415161718192021222324252627282930313233[root@localhost ~]# umount -l /usr1[root@localhost ~]# resize2fs /dev/mapper/vg0-lv1 100Mresize2fs 1.42.9 (28-Dec-2013)Please run 'e2fsck -f /dev/mapper/vg0-lv1' first.[root@localhost ~]# e2fsck -f /dev/mapper/vg0-lv1 e2fsck 1.42.9 (28-Dec-2013)Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information/dev/mapper/vg0-lv1: 2369/206848 files (6.4% non-contiguous), 61211/823296 blocks[root@localhost ~]# [root@localhost ~]# resize2fs /dev/mapper/vg0-lv1 100Mresize2fs 1.42.9 (28-Dec-2013)Resizing the filesystem on /dev/mapper/vg0-lv1 to 102400 (1k) blocks.The filesystem on /dev/mapper/vg0-lv1 is now 102400 blocks long.[root@localhost ~]# lvreduce -L 100M /dev/mapper/vg0-lv1 WARNING: Reducing active logical volume to 100.00 MiB. THIS MAY DESTROY YOUR DATA (filesystem etc.)Do you really want to reduce vg0/lv1? [y/n]: y Size of logical volume vg0/lv1 changed from 804.00 MiB (201 extents) to 100.00 MiB (25 extents). Logical volume vg0/lv1 successfully resized.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert lv1 vg0 -wi-a----- 100.00m [root@localhost /]# vgs VG #PV #LV #SN Attr VSize VFree vg0 2 1 0 wz--n- 804.00m 704.00m[root@localhost /]# pvs PV VG Fmt Attr PSize PFree /dev/sdb1 vg0 lvm2 a-- 296.00m 196.00m /dev/sdc1 vg0 lvm2 a-- 508.00m 508.00m 快照]]></content>
      <categories>
        <category>linux</category>
        <category>tool</category>
        <category>lvm</category>
      </categories>
      <tags>
        <tag>lvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins使用总结]]></title>
    <url>%2F2019%2F05%2F13%2Fjenkins%2Fjenkins%2F</url>
    <content type="text"><![CDATA[常用链接 pipeline steps reference pipeline scm step(checkout) apache groovy doc SAP shared lib repo Jenkins插件默认升级站点配置 groovy实现添加slave 官方wiki pipeline使用官方pipeline示例并行任务配置Jenkins pipeline控制并行执行job个数shared-libpipeline代码调试问题总结Multijob不能调用pipeline任务升级Multijob插件到1.32及以上 admin密码丢失 初始密码: ${jenkins_home}/secrets/initialAdminPassword 修改过密码后忘记1) 将 ${jenkins_home}/config.xml 文件中以下内容修改为false 1&lt;useSecurity&gt;true&lt;/useSecurity&gt; 2) 重启jenkins服务3) 系统管理 -&gt; 全局安全配置 中 启用安全4) 系统管理 -&gt; 管理用户 中 重置密码]]></content>
      <categories>
        <category>tool</category>
        <category>持续集成</category>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>jenkins</tag>
        <tag>pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode使用总结]]></title>
    <url>%2F2019%2F05%2F13%2Fvscode-usage%2F</url>
    <content type="text"><![CDATA[vscode配置12345678&#123; "workbench.colorTheme": "One Dark Pro", "workbench.iconTheme": "vscode-icons", "editor.renderWhitespace": "all", "editor.renderControlCharacters": true, "window.zoomLevel": 0, "editor.fontSize": 16&#125;]]></content>
      <categories>
        <category>tool</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm使用总结]]></title>
    <url>%2F2019%2F05%2F13%2Fnpm-usage%2F</url>
    <content type="text"><![CDATA[npm使用淘宝镜像临时使用1npm --registry https://registry.npm.taobao.org 永久设置1npm config set registry https://registry.npm.taobao.org 该方式等同于在~/.npmrc文件中添加registry=https://registry.npm.taobao.org可以通过npm config get registry确认是否生效 使用cnpm1npm install cnpm -g --registry https://registry.npm.taobao.org cnpm和npm用法完全一致，只是在执行命令时将npm改为cnpm]]></content>
      <categories>
        <category>tool</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建blog]]></title>
    <url>%2F2019%2F05%2F12%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[Hexo是一个快速、简洁且高效的博客框架。具体内容请参考官网文档。 主题Next修改参考官方文档 依赖 nodejs github个人仓库 git hexo安装12345npm install -g hexo-clihexo init blogcd blognpm installnpm install hexo-deployer-git --save _config.yml配置123456language: zh-CN # 网站使用的语言，取值参考themes下面的languages目录中的配置timezone: Asia/Shanghaideploy: type: git # path和username要一致，且git中repo的命令必须为name.github.io repo: git@github.com:path/username.github.io.git 常用hexo命令 hexo init [folder]新建一个网站，如果未指定folder，则默认在当前位置创建 hexo new [layout] 新建文章，如果未指定layout，则使用_config.yml中的default_layout代替 hexo generate [option]生成静态文件，可以简写为hexo g。option: -d,–deploy 文件生成后立即部署 -w,–watch 监视文件变化 hexo server启动服务器。默认访问路径为 http://localhost:4000。可以简写为`hexo s` hexo deploy部署网站。可以简写为hexo d。可以通过指定-g参数指定部署前先生成静态文件。 hexo clean清除缓存文件(db.json)和已生成的静态文件(public/*) Front-matter 参数 描述 备注 layout 布局 title 文章标题 data 创建时间 updated 更新时间 comments 开启评论 默认值:true tags 标签(不适用于分页) 配置多个时，标签没有顺序和层次 categories 分类(不适用于分页) 配置多个时，分类具有顺序和层次 Next增加站内搜索 安装插件 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 修改hexo配置 在hexo目录下的_config.yml中增加以下内容 12345search: path: search.xml field: post format: html limit: 10000 next主题增加搜索入口 在themes/next/_config.yml文件中打开local_search 1234local_search: enable: true trigger: auto top_n_per_article: 1]]></content>
      <categories>
        <category>framework</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
